{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DataEntry Documentation","text":"<p>DataEntry is an advanced Web Component that renders a UI from an endpoint (data) and a schema. This documentation provides an overview of how to use DataEntry, including setting data, schema, lookup data, translations and messages.</p>"},{"location":"#using-html-attributes","title":"Using HTML Attributes","text":"<p>You can set <code>data</code>, <code>schema</code>, <code>lookup</code>, <code>i18n</code> and <code>messages</code> using HTML attributes when declaring the <code>&lt;data-entry&gt;</code> component:</p> <pre><code>&lt;data-entry\n  data=\"your.api/product\"\n  schema=\"your.api/schema\"\n  lookup=\"your.api/lookup\"\n  i18n=\"your.api/translations\"\n  messages=\"your.api/messages\"\n  lang=\"en\"\n  debug&gt;\n&lt;/data-entry&gt;\n</code></pre> <ul> <li><code>data</code>: URL of the data resource (JSON file).</li> <li><code>schema</code>: URL of the schema resource (JSON Schema).</li> <li><code>lookup</code>: URL for global lookup data (optional).</li> <li><code>i18n</code>: URL for translations (optional)</li> <li><code>messages</code>: URL for custom messages (optional).</li> <li><code>lang</code>: Sets the language for translation.</li> <li><code>debug</code>: Enables debug logging to the console.</li> </ul>"},{"location":"#using-javascript","title":"Using JavaScript","text":"<p>If you prefer to set data, schema, or other resources directly using JavaScript, you can do so by accessing the DataEntry instance and its properties.</p>"},{"location":"#setting-data-and-schema-programmatically","title":"Setting Data and Schema Programmatically","text":"<p>You can directly set the <code>data</code>, <code>schema</code>, <code>lookup</code>, <code>i18n</code> or <code>messages</code> using JavaScript:</p> <pre><code>const dataEntry = document.querySelector('data-entry');\n\n// Set data\ndataEntry.data = {\n  id: 1,\n  name: \"Example Product\",\n  description: \"This is an example product.\"\n};\n\n// Set schema\ndataEntry.schema = {\n  type: \"object\",\n  properties: {\n    id: { type: \"number\" },\n    name: { type: \"string\" },\n    description: { type: \"string\" }\n  }\n};\n\n// Set lookup\ndataEntry.lookup = {\n  product_type: [\n    { label: \"Book\", value: 1 },\n    { label: \"Comic\", value: 2 },\n  ]\n};\n\n// Set translations\ndataEntry.i18n = {\n  en: {\n    add: 'Add',\n    close: 'Close',\n  },\n}\n\n// Set messages\ndataEntry.messages = [\n  { code: 400, message: \"Bad Request\", type: \"info\" },\n  { code: 404, message: \"Not Found\", type: \"error\" }\n];\n</code></pre>"},{"location":"#validation-and-form-submission","title":"Validation and Form Submission","text":"<p>DataEntry automatically validates the form based on the provided schema. You can control whether validation is enforced by setting the <code>novalidate</code> attribute.</p>"},{"location":"#auto-save-functionality","title":"Auto-Save Functionality","text":"<p>You can also enable auto-save functionality by specifying the <code>data-auto-save</code> attribute on the form with a time interval (in seconds). The form will automatically submit the data at the given interval.</p> <pre><code>&lt;form data-auto-save=\"60\"&gt; &lt;!-- Auto-save every 60 seconds --&gt;\n</code></pre>"},{"location":"#debugging","title":"Debugging","text":"<p>If you include the <code>debug</code> attribute, DataEntry will log helpful information to the console during rendering, form submissions, and when handling errors.</p>"},{"location":"components/","title":"Components","text":"<p>DataEntry comes with built-in support for various UI components. These components are loaded dynamically based on the HTML content of the form and provide extended functionality, such as auto-suggestions and rich text editors. This document describes the built-in components and how to extend DataEntry with your custom components.</p>"},{"location":"components/#built-in-components","title":"Built-in Components","text":"<p>All built-in components are from browser.style/ui. Read full documentation for each of the components there.</p>"},{"location":"components/#1-autosuggest-auto-suggest","title":"1. AutoSuggest (<code>&lt;auto-suggest&gt;</code>)","text":"<p>The AutoSuggest component provides real-time suggestions as the user types, fetching data from an external API. It automatically populates relevant fields when an option is selected.</p>"},{"location":"components/#example","title":"Example:","text":"<pre><code>&lt;auto-suggest api=\"/api/products\" label=\"Product Name\"&gt;&lt;/auto-suggest&gt;\n</code></pre>"},{"location":"components/#2-richtext-rich-text","title":"2. RichText (<code>&lt;rich-text&gt;</code>)","text":"<p>The RichText component is a WYSIWYG (What You See Is What You Get) editor for input fields requiring formatted text.</p>"},{"location":"components/#example_1","title":"Example:","text":"<pre><code>&lt;rich-text name=\"description\"&gt;&lt;/rich-text&gt;\n</code></pre>"},{"location":"components/#3-uitoast-ui-toast","title":"3. UiToast (<code>&lt;ui-toast&gt;</code>)","text":"<p>The UiToast component is used for displaying toast notifications, such as success or error messages. It is automatically triggered when certain events occur (e.g., form submission) but can also be manually triggered via the <code>showToast</code> method.</p>"},{"location":"components/#example_2","title":"Example:","text":"<pre><code>&lt;ui-toast&gt;&lt;/ui-toast&gt;\n</code></pre>"},{"location":"components/#how-components-are-loaded","title":"How Components are Loaded","text":"<p>In DataEntry, components are dynamically loaded based on the HTML content of the form. The <code>mountComponents</code> function is responsible for checking if the HTML contains certain tags (like <code>&lt;auto-suggest&gt;</code> or <code>&lt;ui-toast&gt;</code>) and then loading the corresponding JavaScript modules.</p> <p>Here\u2019s how components are loaded:</p> <pre><code>export async function mountComponents(HTML, dataEntry) {\n  const importPromises = Object.entries(componentsInfo).map(async ([componentName, { bindFunction, path, tagName }]) =&gt; {\n    if (HTML.includes(`&lt;${tagName}`)) {\n      try {\n        const module = await import(path);\n        module[componentName].mount();\n        if (bindFunction) {\n          bindFunction(dataEntry);\n        }\n      } catch (error) {\n        console.error(`Failed to load component ${componentName}:`, error);\n      }\n    }\n  });\n  await Promise.all(importPromises);\n}\n</code></pre>"},{"location":"components/#how-to-extend-dataentry-with-custom-components","title":"How to Extend DataEntry with Custom Components","text":""},{"location":"components/#1-define-your-custom-component","title":"1. Define Your Custom Component","text":"<p>You can define a custom component as an ES6 class that extends <code>HTMLElement</code>.</p>"},{"location":"components/#example_3","title":"Example:","text":"<pre><code>class MyCustomComponent extends HTMLElement {\n  constructor() {\n    super();\n    this.innerHTML = '&lt;div&gt;Custom Content Here&lt;/div&gt;';\n  }\n}\n\n// Register the custom component\ncustomElements.define('my-custom-component', MyCustomComponent);\n</code></pre>"},{"location":"components/#2-add-the-component-to-componentsinfo","title":"2. Add the Component to <code>componentsInfo</code>","text":"<p>Once you define your custom component, you can add it to the <code>componentsInfo</code> object. This allows the component to be dynamically loaded like the built-in components.</p>"},{"location":"components/#example_4","title":"Example:","text":"<pre><code>const componentsInfo = {\n  MyCustomComponent: {\n    path: '/path/to/my-custom-component.js',\n    tagName: 'my-custom-component',\n  }\n};\n</code></pre>"},{"location":"components/#3-adding-a-custom-bindmethod","title":"3. Adding a custom bindMethod","text":"<p>You can easily add a custom bindMethod to your custom component. Here's an example for the <code>&lt;ui-toast&gt;</code>-component:</p> <pre><code>UiToast: {\n  bindFunction: bindUiToast,\n  path: '/ui/toast/index.js',\n  tagName: 'ui-toast',\n}\n</code></pre> <p>Then, we add the custom <code>bindFunction</code>:</p> <pre><code>function bindUiToast(dataEntry) {\n  const toastElement = dataEntry.form.querySelector('ui-toast');\n  if (toastElement) {\n    dataEntry.showToast = (message, type = 'success', duration = 3000) =&gt; {\n      toastElement.showToast(message, type, duration);\n    };\n  } else {\n    // Fallback if ui-toast is not available\n    dataEntry.showToast = (message, type = 'info', duration = 3000) =&gt; {\n      dataEntry.debugLog(`Toast fallback: ${message} (Type: ${type})`);\n    };\n  }\n}\n</code></pre>"},{"location":"components/#4-use-your-custom-component-in-the-form","title":"4. Use Your Custom Component in the Form","text":"<p>Now, you can use the custom component in your DataEntry form or schema just like any other built-in component.</p>"},{"location":"components/#example-in-html","title":"Example in HTML:","text":"<pre><code>&lt;my-custom-component&gt;&lt;/my-custom-component&gt;\n</code></pre>"},{"location":"components/#example-in-schema","title":"Example in Schema:","text":"<pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"customField\": {\n      \"type\": \"string\",\n      \"title\": \"Custom Field\",\n      \"render\": {\n        \"method\": \"my-custom-component\"\n      }\n    }\n  }\n}\n</code></pre> <p>When this component is encountered in the form or schema, it will be loaded and displayed accordingly.</p>"},{"location":"components/#conclusion","title":"Conclusion","text":"<p>DataEntry's built-in components provide a solid foundation for common UI elements like auto-suggest and rich-text input. However, the extensibility of the system allows you to define and register your custom components, making it a versatile tool for dynamic form generation and user interface customization.</p>"},{"location":"extending/","title":"Extending DataEntry","text":"<p>DataEntry is designed to be flexible and extensible, allowing users to define their own render-methods, custom-methods and dynamic functions. This document explains how to extend DataEntry with these methods and integrate them into your forms.</p>"},{"location":"extending/#extending-render-methods","title":"Extending Render Methods","text":"<p>Render methods are responsible for generating HTML content for specific fields or components in your form. By default, DataEntry comes with a set of built-in render methods. However, you can extend these methods to provide custom rendering behavior.</p>"},{"location":"extending/#how-to-extend-a-render-method","title":"How to Extend a Render Method","text":"<p>To extend a render method, use the <code>extendRenderMethod</code> function. This function allows you to define a new method and make it available to your form schema.</p>"},{"location":"extending/#example-of-extending-a-render-method","title":"Example of Extending a Render Method:","text":"<pre><code>const myRenderMethod = (params) =&gt; {\n  const { label, value, attributes } = params;\n  return `&lt;label&gt;${label}&lt;input type=\"text\" value=\"${value}\" ${attributes}&gt;&lt;/label&gt;`;\n};\n\n// Extend DataEntry with the new render method\ninstance.extendRenderMethod('myRenderMethod', myRenderMethod);\n</code></pre> <p>In this example: - The <code>myRenderMethod</code> is defined to render a simple input field with a label. - It is then added to DataEntry using the <code>extendRenderMethod</code> function.</p> <p>Once extended, this render method can be used in your schema like so:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"custom_field\": {\n      \"type\": \"string\",\n      \"title\": \"Custom Field\",\n      \"render\": {\n        \"method\": \"myRenderMethod\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"extending/#extending-custom-methods","title":"Extending Custom Methods","text":"<p>Custom methods in DataEntry provide the ability to define custom behavior for elements. These methods are typically triggered by user interactions (such as <code>onclick</code> events) and are defined using <code>data-custom</code> attributes in your schema- and render methods.</p>"},{"location":"extending/#how-to-extend-a-custom-method","title":"How to Extend a Custom Method","text":"<p>To define a custom method, use the <code>extendCustomMethod</code> function. This allows you to add a custom method that will be triggered by user interactions.</p>"},{"location":"extending/#example-of-extending-a-custom-method","title":"Example of Extending a Custom Method:","text":"<pre><code>const myCustomMethod = (element, instance, ...params) =&gt; {\n  console.log(\"Custom method triggered with parameters:\", params);\n  element.style.backgroundColor = 'yellow';\n};\n\n// Extend DataEntry with the custom method\ninstance.extendCustomMethod('highlight', myCustomMethod);\n</code></pre> <p>In this example: - The <code>highlight</code> method changes the background color of the element when triggered. - The method is then added to DataEntry using the <code>extendCustomMethod</code> function.</p> <p>You can trigger this method by adding a <code>data-custom</code> attribute to an element in your schema:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"highlighted_field\": {\n      \"type\": \"string\",\n      \"title\": \"Highlighted Field\",\n      \"render\": {\n        \"method\": \"input\",\n        \"attributes\": [\n          {\n            \"data-custom\": \"highlight\"\n          }\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>When the element (in this case, an input field) is clicked, the <code>highlight</code> method will be triggered.</p>"},{"location":"extending/#using-data-params-to-pass-parameters","title":"Using <code>data-params</code> to Pass Parameters","text":"<p>In addition to <code>data-custom</code>, you can use the <code>data-params</code> attribute to pass parameters to your custom method. This allows for more dynamic behavior based on the provided parameters.</p>"},{"location":"extending/#example","title":"Example:","text":"<pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"dynamic_field\": {\n      \"type\": \"string\",\n      \"title\": \"Dynamic Field\",\n      \"render\": {\n        \"method\": \"input\",\n        \"attributes\": [\n          {\n            \"data-custom\": \"highlight\",\n            \"data-params\": \"{ color: 'blue' }\"\n          }\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>In this example: - The <code>data-params</code> attribute is used to pass a <code>color</code> parameter to the <code>highlight</code> method. - The custom method can then access this parameter and adjust its behavior accordingly.</p>"},{"location":"extending/#extending-with-dynamic-functions","title":"Extending with Dynamic Functions","text":"<p>In addition to render and custom methods, DataEntry supports dynamic functions that allow you to perform operations or transformations dynamically.</p>"},{"location":"extending/#how-to-extend-a-dynamic-function","title":"How to Extend a Dynamic Function","text":"<p>You can extend dynamic functions using the <code>extendDynamicFunction</code> method, which makes the function available across your form schema.</p>"},{"location":"extending/#example_1","title":"Example:","text":"<pre><code>const currentDateFunction = () =&gt; new Date().toISOString().split('T')[0];\n\n// Extend DataEntry with the new dynamic function\ninstance.extendDynamicFunction('currentDate', currentDateFunction);\n</code></pre> <p>You can then use this dynamic function in your schema by referencing it:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"date_field\": {\n      \"type\": \"string\",\n      \"title\": \"Date\",\n      \"render\": {\n        \"method\": \"input\",\n        \"attributes\": [\n          {\n            \"value\": \"${d:currentDate}\"\n          }\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>In this example: - The <code>currentDate</code> function dynamically generates the current date and populates the <code>value</code> attribute of the input field.</p>"},{"location":"extending/#syntax-for-extending-dynamic-functions","title":"Syntax for Extending Dynamic Functions","text":"<pre><code>export function extendDynamicFunction(name, func) {\n  if (typeof func === 'function') {\n    dynamicFunctions[name] = func;\n  } else {\n    console.error(`Failed to extend: ${name} is not a function`);\n  }\n}\n</code></pre>"},{"location":"extending/#example_2","title":"Example:","text":"<pre><code>// Define a custom dynamic function that returns the current year\nextendDynamicFunction('currentYear', () =&gt; {\n  return new Date().getFullYear();\n});\n\n// Now you can use ${d:currentYear} in your schema\n</code></pre>"},{"location":"extending/#usage-in-schema","title":"Usage in Schema:","text":"<pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"year\": {\n      \"type\": \"number\",\n      \"title\": \"Year\",\n      \"value\": \"${d:currentYear}\",\n      \"render\": {\n        \"method\": \"input\",\n        \"attributes\": [\n          { \"name\": \"year\" }\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>In this example: - The year field will automatically be populated with the current year using the custom <code>currentYear</code> dynamic function.</p>"},{"location":"lookup/","title":"Lookup Data","text":"<p>Lookup data in DataEntry is a powerful feature that allows you to define reusable datasets that can be referenced in your schema to dynamically populate options in fields like dropdowns (<code>&lt;select&gt;</code>). This feature simplifies managing common lists, such as product types, conditions, or statuses, across your application.</p>"},{"location":"lookup/#using-the-lookup-endpoint","title":"Using the Lookup Endpoint","text":"<p>Lookup data is typically provided via an external endpoint, loaded using the <code>lookup</code> attribute on the DataEntry component.</p>"},{"location":"lookup/#example-data-from-a-lookup-endpoint","title":"Example Data from a Lookup Endpoint","text":"<p>An example response from the global data endpoint might look like this:</p> <pre><code>{\n  \"condition\": [\n    { \"label\": \"New\", \"value\": 1 },\n    { \"label\": \"Used\", \"value\": 2 },\n    { \"label\": \"Refurbished\", \"value\": 3 }\n  ],\n  \"product_type\": [\n    { \"label\": \"Book\", \"value\": 1 },\n    { \"label\": \"Comic\", \"value\": 2 },\n    { \"label\": \"Figure\", \"value\": 3 },\n    { \"label\": \"Film\", \"value\": 4 },\n    { \"label\": \"Game\", \"value\": 5 }\n  ]\n}\n</code></pre> <p>In this example: - <code>condition</code> is a list of conditions with labels (New, Used, Refurbished) and corresponding values. - <code>product_type</code> is a list of product types (Book, Comic, etc.) with associated values.</p> <p>These lists can be used in your schema to populate <code>&lt;select&gt;</code> fields with dynamic options.</p>"},{"location":"lookup/#defining-the-lookup-data-endpoint-in-dataentry","title":"Defining the Lookup Data Endpoint in DataEntry","text":"<p>You can define the global data source by specifying a URL in the <code>lookup</code> attribute. DataEntry will then fetch this data and use it to populate fields as needed.</p>"},{"location":"lookup/#example-usage","title":"Example Usage:","text":"<pre><code>&lt;data-entry\n  data=\"your.api/product\"\n  schema=\"your.api/schema\"\n  lookup=\"your.api/lookup\"\n&gt;&lt;/data-entry&gt;\n</code></pre> <p>In this example: - The <code>lookup</code> attribute points to an endpoint that contains global data, like the example shown above. - The schema and data are loaded via their respective endpoints.</p>"},{"location":"lookup/#using-global-data-in-the-schema","title":"Using Global Data in the Schema","text":"<p>To reference global data in your schema, simply provide the key from the global data object in the <code>options</code> field of a <code>select</code> input.</p>"},{"location":"lookup/#example-schema-with-global-data","title":"Example Schema with Global Data:","text":"<pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"product_type_id\": {\n      \"type\": \"number\",\n      \"title\": \"Product Type\",\n      \"render\": {\n        \"method\": \"select\",\n        \"options\": \"product_type\"\n      }\n    },\n    \"condition_id\": {\n      \"type\": \"number\",\n      \"title\": \"Condition\",\n      \"render\": {\n        \"method\": \"select\",\n        \"options\": \"condition\"\n      }\n    }\n  }\n}\n</code></pre> <p>In this schema: - The <code>product_type_id</code> field uses the <code>product_type</code> global data to populate its options. - The <code>condition_id</code> field uses the <code>condition</code> global data for its dropdown options.</p> <p>When DataEntry renders these fields, it will look for the <code>options</code> key (e.g., <code>product_type</code> or <code>condition</code>) in the global data, and if found, it will populate the dropdown (<code>&lt;select&gt;</code>) with the corresponding <code>label</code> and <code>value</code> pairs.</p>"},{"location":"lookup/#example-of-the-rendered-select-fields","title":"Example of the Rendered Select Fields:","text":"<pre><code>&lt;select name=\"product_type_id\"&gt;\n  &lt;option value=\"1\"&gt;Book&lt;/option&gt;\n  &lt;option value=\"2\"&gt;Comic&lt;/option&gt;\n  &lt;option value=\"3\"&gt;Figure&lt;/option&gt;\n  &lt;option value=\"4\"&gt;Film&lt;/option&gt;\n  &lt;option value=\"5\"&gt;Game&lt;/option&gt;\n&lt;/select&gt;\n\n&lt;select name=\"condition_id\"&gt;\n  &lt;option value=\"1\"&gt;New&lt;/option&gt;\n  &lt;option value=\"2\"&gt;Used&lt;/option&gt;\n  &lt;option value=\"3\"&gt;Refurbished&lt;/option&gt;\n&lt;/select&gt;\n</code></pre>"},{"location":"lookup/#key-takeaways","title":"Key Takeaways:","text":"<ul> <li>Global Data: Use global data to populate dropdowns and other dynamic lists across your forms.</li> <li>Endpoint: Specify the endpoint for the global data in the <code>lookup</code> (or <code>global-data</code>) attribute of DataEntry.</li> <li>Options Key: Reference the global data in your schema using the <code>options</code> field in the <code>render</code> object.</li> <li>Reusable: By centralizing common data lists, you can reuse them across multiple form fields, reducing duplication and ensuring consistency.</li> </ul>"},{"location":"messages/","title":"Messages","text":"<p>In DataEntry, messages provide valuable feedback to the user, offering insights into various actions, errors, or warnings that occur during interactions with the form. These messages can be loaded from an external endpoint using the <code>messages</code> attribute or extended directly within the schema.</p> <p>Messages are typically displayed as Toasts in the UI, offering brief and non-intrusive notifications.</p> <p>As a fallback, if the <code>debug</code> flag is set on DataEntry, messages are logged in the console.</p>"},{"location":"messages/#sample-messages-from-the-messages-endpoint","title":"Sample Messages from the Messages Endpoint","text":"<p>A typical response from a messages endpoint might look like this:</p> <pre><code>[\n  {\n    \"code\": 400,\n    \"message\": \"Bad Request - Please check your inputs.\",\n    \"type\": \"info\"\n  },\n  {\n    \"code\": 404,\n    \"message\": \"Product not found.\",\n    \"type\": \"warning\"\n  },\n  {\n    \"code\": 405,\n    \"message\": \"Could not save data\",\n    \"type\": \"error\"\n  },\n  {\n    \"code\": 1105,\n    \"message\": \"Could not save data\",\n    \"type\": \"error\"\n  }\n]\n</code></pre>"},{"location":"messages/#fields-in-a-message","title":"Fields in a Message:","text":"<ul> <li>code: The status code or identifier for the message.</li> <li>message: The text that will be displayed to the user.</li> <li>type: The type of message, which affects how it is displayed. Common types include:</li> <li><code>success</code>: Action performed succesfully</li> <li><code>info</code>: General information messages.</li> <li><code>warning</code>: Warnings that indicate a potential issue.</li> <li><code>error</code>: Errors indicating that something went wrong.</li> </ul>"},{"location":"messages/#example-usage-in-dataentry","title":"Example Usage in DataEntry:","text":"<pre><code>&lt;data-entry\n  data=\"your.api/data\"\n  schema=\"your.api/schema\"\n  messages=\"your.api/messages\"\n  debug&gt;\n&lt;/data-entry&gt;\n</code></pre> <p>In this example: - The <code>messages</code> attribute points to an endpoint that contains an array of messages like the one shown above. - These messages will be used to provide feedback to the user during interactions.</p>"},{"location":"messages/#overriding-or-extending-messages-in-the-schema","title":"Overriding or Extending Messages in the Schema","text":"<p>You can also override or extend messages directly in the DataEntry schema. This is useful when specific fields or actions in the form require custom messages.</p>"},{"location":"messages/#example-of-extending-messages-in-the-schema","title":"Example of Extending Messages in the Schema:","text":"<pre><code>{\n  \"messages\": [\n    {\n      \"code\": 405,\n      \"message\": \"Could not save data AT all!\",\n      \"type\": \"error\"\n    }\n  ]\n}\n</code></pre> <p>In this example: - The schema extends the messages by providing a custom message for the <code>405</code> code, overriding the one from the messages endpoint. - The custom message reads \"Could not save data AT all!\" and is of type <code>error</code>.</p>"},{"location":"messages/#displaying-messages","title":"Displaying Messages","text":"<p>Messages are primarily displayed in two ways: 1. Toast Notifications: Messages are shown as toasts in the UI for a short duration. 2. Console Logging (Debug Mode): When the <code>debug</code> flag is set on DataEntry, any message that would normally appear as a toast is also logged in the console.</p> <p>The built-in <code>&lt;ui-toast&gt;</code>-component exposes <code>::part</code>\u00b4s and can thus be custom styled. </p> <p>For more information, see browser.style/ui/toast</p>"},{"location":"translations/","title":"Translations","text":"<p>DataEntry supports flexible and dynamic translations through the use of an <code>i18n</code> attribute or setter method. This enables developers to control translations from an endpoint or directly via JavaScript, offering a more dynamic way to handle internationalization in form rendering.</p>"},{"location":"translations/#setting-up-translations","title":"Setting Up Translations","text":""},{"location":"translations/#using-the-i18n-attribute","title":"Using the <code>i18n</code> Attribute","text":"<p>You can specify an endpoint for translations using the <code>i18n</code> attribute on the <code>&lt;data-entry&gt;</code> component. This attribute points to an API or JSON file containing translation keys and values for different languages.</p> <p>Example: <pre><code>&lt;data-entry\n    data=\"your.api/product\"\n    schema=\"your.api/schema\"\n    i18n=\"your.api/i18n\"\n    lang=\"en\"&gt;\n&lt;/data-entry&gt;\n</code></pre></p> <p>In the above example, the <code>i18n</code> attribute fetches a JSON file containing translation mappings. The <code>lang</code> attribute is used to specify the current language, which can be switched dynamically.</p>"},{"location":"translations/#setting-translations-programmatically","title":"Setting Translations Programmatically","text":"<p>If you prefer to set translations directly via JavaScript, you can use the <code>i18n</code> setter. This allows you to manually load and set translations for the <code>DataEntry</code> component.</p> <pre><code>const myDataEntry = document.querySelector('data-entry');\nmyDataEntry.i18n = {\n  en: {\n    add: 'Add',\n    close: 'Close',\n    details: 'Details',\n    release_date: 'Release Date',\n    reset: 'Reset',\n  },\n  da: {\n    add: 'Tilf\u00f8j',\n    close: 'Luk',\n    details: 'Detaljer',\n    release_date: 'Udgivelsesdato',\n      reset: 'Nulstil',\n  }\n};\n</code></pre>"},{"location":"translations/#dynamically-loaded-translations","title":"Dynamically Loaded Translations","text":"<p>When the <code>i18n</code> attribute is used, translations are dynamically loaded from the specified endpoint. The translations object can then be accessed via the <code>this.instance.i18n</code> object after the <code>loadResources</code> method completes.</p> <pre><code>class DataEntry extends HTMLElement {\n  async connectedCallback() {\n    // Load resources including translations\n    await this.loadResources();\n\n    // Set the instance i18n after loading the resources\n    this.instance.i18n = this.i18n || {};\n\n    // Now translations are available\n    console.log(this.instance.i18n);\n  }\n}\n</code></pre>"},{"location":"translations/#translation-method-t-function","title":"Translation Method (<code>t</code> function)","text":"<p>The <code>t</code> function is used internally to translate keys in the form schema or other parts of the UI. It looks up the key in the <code>i18n</code> object based on the current language.</p> <pre><code>export function t(key, lang, i18n) {\n    return i18n[lang]?.[key] || key;\n}\n</code></pre> <p>If a translation key starts with <code>${t:}</code>, the system knows it refers to a translatable string, and the key will be replaced by the corresponding translation in the specified language.</p> <p>Example usage in a schema: <pre><code>{\n  \"title\": \"${t:details}\",\n  \"properties\": {\n    \"release_date\": {\n      \"type\": \"string\",\n      \"title\": \"${t:release_date}\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"translations/#setting-the-language","title":"Setting the Language","text":"<p>The language for translations is set using the <code>lang</code> attribute or via the <code>this.instance.lang</code> property. This determines which language from the <code>i18n</code> object is used for translations.</p> <pre><code>&lt;data-entry lang=\"en\" i18n=\"your.api/i18n.json\"&gt;&lt;/data-entry&gt;\n</code></pre> <p>You can also change the language dynamically in JavaScript:</p> <pre><code>myDataEntry.lang = 'da';\n</code></pre> <p>This will instantly switch the UI to Danish if the relevant translations are available in the <code>i18n</code> object.</p>"},{"location":"schema/additional/","title":"Additional Rendering Methods in DataEntry","text":"<p>Below are the descriptions of additional rendering methods in DataEntry, such as <code>arrayCheckbox</code>, <code>arrayGrid</code>, <code>entry</code>, <code>fieldset</code>, and more. These methods provide more complex functionality and control over how specific fields or arrays are displayed.</p>"},{"location":"schema/additional/#render-methods","title":"Render Methods","text":""},{"location":"schema/additional/#1-array-checkbox","title":"1. Array Checkbox","text":"<p>Renders an array of checkboxes, where each checkbox corresponds to an item in the array.</p>"},{"location":"schema/additional/#example","title":"Example:","text":"<pre><code>{\n  \"type\": \"array\",\n  \"title\": \"Jobs\",\n  \"render\": {\n    \"method\": \"array-checkbox\",\n    \"attributes\": [\n      { \"part\": \"array-checkbox\" }\n    ],\n    \"summary\": \"active\",\n    \"label\": \"job_name\"\n  }\n}\n</code></pre> <ul> <li>Attributes: Defines the part attribute for the array checkbox.</li> <li>summary: Defines the field to be summarized in the checkbox.</li> <li>label: The field label shown for each checkbox item.</li> </ul>"},{"location":"schema/additional/#2-array-grid","title":"2. Array Grid","text":"<p>Renders an array of items in a grid format, where each item is displayed as a set of fields.</p>"},{"location":"schema/additional/#example_1","title":"Example:","text":"<pre><code>{\n  \"type\": \"array\",\n  \"title\": \"Reviews\",\n  \"render\": {\n    \"method\": \"array-grid\",\n    \"attributes\": [\n      { \"part\": \"array-grid\" }\n    ],\n    \"label\": \"&amp;nbsp;\",\n    \"value\": \"&amp;nbsp;\",\n    \"add\": true,\n    \"delete\": true\n  }\n}\n</code></pre> <ul> <li>Attributes: Specifies grid-related attributes.</li> <li>label and value: Optional settings for array-grid labels and values.</li> </ul>"},{"location":"schema/additional/#3-entry","title":"3. Entry","text":"<p>The <code>entry</code> method renders an entry form for adding new items to an array. It is often used in conjunction with methods like <code>array-details</code> or <code>array-checkbox</code>.</p>"},{"location":"schema/additional/#example_2","title":"Example:","text":"<pre><code>{\n  \"render\": {\n    \"method\": \"entry\",\n    \"attributes\": [\n      { \"form\": \"entryForm\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>Attributes: HTML attributes like <code>form</code> for managing form submission or settings.</li> </ul>"},{"location":"schema/additional/#4-fieldset","title":"4. Fieldset","text":"<p>The <code>fieldset</code> method is used to group multiple fields under one common title.</p>"},{"location":"schema/additional/#example_3","title":"Example:","text":"<pre><code>{\n  \"render\": {\n    \"method\": \"fieldset\",\n    \"attributes\": [\n      { \"part\": \"fieldset\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>Attributes: You can define various attributes to customize the fieldset, such as <code>part</code> or <code>name</code>.</li> </ul>"},{"location":"schema/additional/#5-icon","title":"5. Icon","text":"<p>The <code>icon</code> method is used to render an icon in the UI. This method often interacts with other render methods to provide visual enhancements.</p>"},{"location":"schema/additional/#example_4","title":"Example:","text":"<pre><code>{\n  \"render\": {\n    \"method\": \"icon\",\n    \"attributes\": [\n      { \"name\": \"delete-icon\" },\n      { \"type\": \"icon\" }\n    ]\n  }\n}\n</code></pre>"},{"location":"schema/additional/#6-media","title":"6. Media","text":"<p>The <code>media</code> method is used to render image or media fields. For instance, it can be used to display uploaded images or external media.</p>"},{"location":"schema/additional/#example_5","title":"Example:","text":"<pre><code>{\n  \"type\": \"object\",\n  \"render\": {\n    \"method\": \"media\",\n    \"attributes\": [\n      { \"name\": \"media_url\" },\n      { \"alt\": \"image description\" }\n    ],\n    \"summary\": \"url\",\n    \"label\": \"media_id\"\n  }\n}\n</code></pre> <ul> <li>Attributes: Attributes related to media display like <code>alt</code>, <code>name</code>, etc.</li> <li>label and summary: Define how to display media properties in the rendered output.</li> </ul>"},{"location":"schema/additional/#7-richtext","title":"7. Richtext","text":"<p>Renders a rich text editor with customizable toolbar options.</p>"},{"location":"schema/additional/#example_6","title":"Example:","text":"<pre><code>{\n  \"type\": \"string\",\n  \"render\": {\n    \"method\": \"richtext\",\n    \"attributes\": [\n      { \"toolbar\": \"h1,h2,b,i,u\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>Attributes: Specifies toolbar options like <code>h1</code>, <code>h2</code>, <code>bold</code>, <code>italic</code>, <code>underline</code>, etc.</li> </ul>"},{"location":"schema/additional/#8-textarea","title":"8. Textarea","text":"<p>Renders a <code>&lt;textarea&gt;</code> for multi-line text input.</p>"},{"location":"schema/additional/#example_7","title":"Example:","text":"<pre><code>{\n  \"render\": {\n    \"method\": \"textarea\",\n    \"attributes\": [\n      { \"placeholder\": \"Enter description\" },\n      { \"rows\": \"5\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>Attributes: HTML attributes like <code>placeholder</code>, <code>rows</code>, etc.</li> </ul>"},{"location":"schema/additional/#using-select-options","title":"Using Select Options","text":"<p>The <code>select</code> method, which renders a dropdown <code>&lt;select&gt;</code>, can populate its options in two ways: 1. Array of Objects: You can provide an array of objects with <code>key</code> and <code>value</code> properties for direct options.    <pre><code>{\n  \"render\": {\n    \"method\": \"select\",\n    \"options\": [\n      { \"key\": \"1\", \"value\": \"Option 1\" },\n      { \"key\": \"2\", \"value\": \"Option 2\" }\n    ]\n  }\n}\n</code></pre></p> <ol> <li> <p>Lookup Key: You can provide a string as the <code>options</code> value. This will be used as a lookup key to fetch global data from the <code>lookup</code> attribute (or potentially <code>global-data</code>) in the DataEntry component.    <pre><code>{\n  \"render\": {\n    \"method\": \"select\",\n    \"options\": \"product_type\"\n  }\n}\n</code></pre></p> </li> <li> <p>Global Data: The global data is loaded via the <code>lookup</code> attribute (or <code>global-data</code>). This is a dataset used across multiple fields in the schema, enabling centralized management of options and other dynamic data.</p> </li> </ol>"},{"location":"schema/additional/#example-of-using-global-data","title":"Example of Using Global Data:","text":"<pre><code>{\n  \"lookup\": {\n    \"product_type\": [\n      { \"key\": \"1\", \"value\": \"Electronics\" },\n      { \"key\": \"2\", \"value\": \"Books\" }\n    ]\n  },\n  \"properties\": {\n    \"product_type_id\": {\n      \"type\": \"number\",\n      \"title\": \"Product Type\",\n      \"render\": {\n        \"method\": \"select\",\n        \"options\": \"product_type\"\n      }\n    }\n  }\n}\n</code></pre> <p>In this example, the <code>product_type_id</code> field is rendered as a select dropdown, with the options being fetched from the global <code>lookup</code> dataset.</p>"},{"location":"schema/additional/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>array-checkbox, array-grid, media, and other methods give more advanced controls for rendering specific data types.</li> <li>Global Data (via <code>lookup</code> or <code>global-data</code>) is crucial for managing shared options across multiple form fields.</li> <li>Each render method supports customization through the <code>render</code> object and additional attributes.</li> </ul>"},{"location":"schema/dynamic/","title":"Dynamic Functions","text":"<p>Dynamic functions in DataEntry provide a flexible way to inject dynamic values into the schema. These functions can be used to generate values that are evaluated at runtime, such as timestamps, unique identifiers, or other user-defined logic. This document explains the built-in dynamic functions, how to extend them with custom functions, and how to use them in the schema.</p>"},{"location":"schema/dynamic/#built-in-dynamic-functions","title":"Built-in Dynamic Functions","text":""},{"location":"schema/dynamic/#1-now","title":"1. now","text":"<p>The <code>now</code> function returns the current date and time in the format <code>yyyy-MM-ddThh:mm</code>. This can be used for setting default date-time values in the schema.</p>"},{"location":"schema/dynamic/#example-output","title":"Example Output:","text":"<pre><code>2024-09-23T14:30\n</code></pre>"},{"location":"schema/dynamic/#2-uuid","title":"2. uuid","text":"<p>The <code>uuid</code> function generates a universally unique identifier (UUID). This is useful when you need to create unique keys for new data entries.</p>"},{"location":"schema/dynamic/#example-output_1","title":"Example Output:","text":"<pre><code>b1b754a0-5c12-11ec-bf63-0242ac130002\n</code></pre>"},{"location":"schema/dynamic/#3-today","title":"3. today","text":"<p>The <code>today</code> function returns the current date in <code>yyyy-MM-dd</code> format, which is commonly used for date input fields.</p>"},{"location":"schema/dynamic/#example-output_2","title":"Example Output:","text":"<pre><code>2024-09-23\n</code></pre>"},{"location":"schema/dynamic/#using-dynamic-functions-in-the-schema","title":"Using Dynamic Functions in the Schema","text":"<p>You can use dynamic functions directly within the schema to set default values for form fields. The values generated by these functions are injected into the form at runtime.</p>"},{"location":"schema/dynamic/#syntax-for-using-dynamic-functions","title":"Syntax for Using Dynamic Functions","text":"<p>Dynamic functions in the schema should be referenced using the following pattern:</p> <pre><code>\"value\": \"${d:functionName}\"\n</code></pre> <p>Here, <code>${d:functionName}</code> represents a dynamic function, where <code>d</code> stands for \"dynamic\" and <code>functionName</code> is the name of the function you want to call.</p>"},{"location":"schema/dynamic/#example","title":"Example:","text":"<pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"created_at\": {\n      \"type\": \"string\",\n      \"title\": \"Created At\",\n      \"value\": \"${d:now}\",\n      \"render\": {\n        \"method\": \"input\",\n        \"attributes\": [\n          { \"name\": \"created_at\" }\n        ]\n      }\n    },\n    \"unique_id\": {\n      \"type\": \"string\",\n      \"title\": \"Unique ID\",\n      \"value\": \"${d:uuid}\",\n      \"render\": {\n        \"method\": \"input\",\n        \"attributes\": [\n          { \"name\": \"unique_id\" }\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>In this example: - The created_at field will have the current date and time as the default value. - The unique_id field will have a generated UUID as the default value.</p>"},{"location":"schema/dynamic/#extending-dynamic-functions","title":"Extending Dynamic Functions","text":"<p>You can define your own dynamic functions to extend the functionality provided by DataEntry. To do this, use the <code>extendDynamicFunction</code> method \u2014 see Extending DataEntry.</p>"},{"location":"schema/extend/","title":"Extending the Schema","text":"<p>When working with the DataEntry component, the schema can be extended with several additional fields that define how the component renders content and behaves. The following sections explain how to extend the schema with Navigation, Headline, Title, and Form Buttons.</p>"},{"location":"schema/extend/#navigation","title":"Navigation","text":"<p>The <code>navigation</code> attribute in the schema defines a navigation menu that can be rendered dynamically based on the schema's structure. It creates links to specific sections within the document.</p> <ul> <li> <p>Syntax: <pre><code>\"navigation\": \"nav\"\n</code></pre></p> </li> <li> <p>Usage: This specifies the part attribute to be applied to the <code>&lt;nav&gt;</code> element that renders the navigation. It\u2019s useful when the form is long or contains multiple sections, allowing quick navigation between different sections of the UI.</p> </li> <li>How it works: Each array or object field in your schema will generate a link within the navigation. The part attribute value will define styling for the navigation.</li> </ul>"},{"location":"schema/extend/#headline","title":"Headline","text":"<p>The <code>headline</code> attribute allows you to dynamically render a title or heading at the top of your form, based on values in your data. It can also support localization via the <code>${}</code> pattern.</p> <ul> <li>Syntax:   <pre><code>\"headline\": \"${name} (${id})\"\n</code></pre></li> <li>Usage: This renders a dynamic headline where <code>${name}</code> and <code>${id}</code> are replaced with the actual values from the data. You can use any data field enclosed in <code>${}</code> to populate the headline.</li> <li>Translation: If you want the headline to support translation, you can use <code>${t:}</code> to mark parts of the headline that need translation. For example:   <pre><code>\"headline\": \"${t:product_name} (${id})\"\n</code></pre></li> </ul>"},{"location":"schema/extend/#title","title":"Title","text":"<p>The <code>title</code> attribute is a static or dynamic string that appears as the legend for the root fieldset of the form.</p> <ul> <li>Syntax:   <pre><code>\"title\": \"${t:details}\"\n</code></pre></li> <li>Usage: This attribute works similarly to the headline, but it is specifically used to title the root fieldset of the form. The value can be either static or dynamic, with support for localization using <code>${t:}</code> for translation. For example, <code>${t:details}</code> will be replaced by a translated string like \"Details\" based on the current <code>lang</code> setting.</li> </ul>"},{"location":"schema/extend/#form-buttons","title":"Form Buttons","text":"<p>The <code>form</code> attribute defines the buttons that appear at the bottom of the form. These can include reset, submit, and other custom actions.</p> <ul> <li>Syntax:   <pre><code>\"form\": [\n  {\n    \"type\": \"reset\",\n    \"label\": \"Reset\"\n  },\n  {\n    \"action\": \"/api/DeleteProduct/:id\",\n    \"label\": \"${t:delete}\",\n    \"method\": \"DELETE\",\n    \"contentType\": \"form\"\n  },\n  {\n    \"action\": \"/api/SetProduct/:id\",\n    \"label\": \"${t:post}\",\n    \"method\": \"POST\",\n    \"contentType\": \"json\"\n  },\n  {\n    \"type\": \"submit\",\n    \"label\": \"Submit\",\n    \"autoSave\": 0\n  }\n]\n</code></pre></li> </ul>"},{"location":"schema/extend/#button-types","title":"Button Types:","text":"<ol> <li>Reset: A reset button clears the form's inputs.    <pre><code>{\n  \"type\": \"reset\",\n  \"label\": \"Reset\"\n}\n</code></pre></li> <li> <p>label: Text displayed on the button.</p> </li> <li> <p>Custom Action Buttons: These buttons perform actions like sending a <code>DELETE</code> or <code>POST</code> request.    <pre><code>{\n  \"action\": \"/api/DeleteProduct/:id\",\n  \"label\": \"${t:delete}\",\n  \"method\": \"DELETE\",\n  \"contentType\": \"form\"\n}\n</code></pre></p> </li> <li>action: The endpoint to send data to.</li> <li>label: Text displayed on the button (can be localized using <code>${t:}</code>).</li> <li>method: HTTP method used (<code>POST</code>, <code>DELETE</code>, etc.).</li> <li> <p>contentType: Specifies the format for sending the data (e.g., <code>form</code>, <code>json</code>).</p> </li> <li> <p>Submit: A submit button sends the form data when clicked.    <pre><code>{\n  \"type\": \"submit\",\n  \"label\": \"Submit\",\n  \"autoSave\": 0\n}\n</code></pre></p> </li> <li>label: Text displayed on the button.</li> <li>autoSave: Optionally auto-save form data (set <code>0</code> to disable).</li> </ol>"},{"location":"schema/extend/#localization","title":"Localization:","text":"<ul> <li>Button labels can be localized using <code>${t:}</code> keys.   <pre><code>{\n  \"label\": \"${t:delete}\"\n}\n</code></pre>   This key will be translated based on the language set in the <code>lang</code> attribute of the <code>DataEntry</code> component.</li> </ul>"},{"location":"schema/extend/#example-of-a-schema-with-extended-fields","title":"Example of a Schema with Extended Fields:","text":"<pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2019-09/schema\",\n  \"type\": \"object\",\n\n  \"navigation\": \"nav\",\n  \"headline\": \"${name} (${id})\",\n  \"title\": \"${t:details}\",\n\n  \"form\": [\n    {\n      \"type\": \"reset\",\n      \"label\": \"Reset\"\n    },\n    {\n      \"action\": \"/api/DeleteProduct/:id\",\n      \"label\": \"${t:delete}\",\n      \"method\": \"DELETE\",\n      \"contentType\": \"form\"\n    },\n    {\n      \"action\": \"/api/SetProduct/:id\",\n      \"label\": \"${t:post}\",\n      \"method\": \"POST\",\n      \"contentType\": \"json\"\n    },\n    {\n      \"type\": \"submit\",\n      \"label\": \"Submit\",\n      \"autoSave\": 0\n    }\n  ],\n\n  \"properties\": {\n    \"id\": {\n      \"type\": \"number\",\n      \"title\": \"Id\"\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"title\": \"Name\"\n    }\n  }\n}\n</code></pre>"},{"location":"schema/jsonschema/","title":"What is a JSON Schema?","text":"<p>JSON Schema is a powerful tool for validating and describing the structure of JSON data. It defines the expected format, structure, and rules for JSON objects. JSON Schema is used extensively for data validation, API contracts, form generation, and many other applications.</p>"},{"location":"schema/jsonschema/#what-does-json-schema-do","title":"What Does JSON Schema Do?","text":"<p>JSON Schema allows you to: - Describe Data: Define what kind of data your JSON objects should contain. - Validate Data: Ensure that the data you receive or store conforms to the expected structure and rules. - Automate Form Generation: Use schemas to automatically generate input forms and user interfaces. - Standardize APIs: Clearly define input and output structures for APIs.</p>"},{"location":"schema/jsonschema/#key-components-of-json-schema","title":"Key Components of JSON Schema","text":""},{"location":"schema/jsonschema/#schema","title":"<code>$schema</code>","text":"<p>Defines the version of the JSON Schema being used. Example: <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2019-09/schema\"\n}\n</code></pre></p>"},{"location":"schema/jsonschema/#id","title":"<code>$id</code>","text":"<p>A unique identifier for the schema. This helps when you have multiple schemas or need to reference schemas externally. Example: <pre><code>{\n  \"$id\": \"http://example.com/example.json\"\n}\n</code></pre></p>"},{"location":"schema/jsonschema/#type","title":"<code>type</code>","text":"<p>Specifies the data type for a property. Supported types include: - object: A JSON object (dictionary-like structure). - array: A list of items. - string: A sequence of characters. - number: A numeric value. - boolean: A true or false value. - null: A null value (no data).</p> <p>Example: <pre><code>{\n  \"type\": \"string\"\n}\n</code></pre></p>"},{"location":"schema/jsonschema/#properties","title":"<code>properties</code>","text":"<p>Defines the keys (or properties) within an object and their corresponding schema definitions. Each property has its own rules and types.</p> <p>Example: <pre><code>{\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"type\": \"number\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"schema/jsonschema/#required","title":"<code>required</code>","text":"<p>Lists the properties that are mandatory in a JSON object. If any of these properties are missing, the validation will fail.</p> <p>Example: <pre><code>{\n  \"required\": [\"name\", \"age\"]\n}\n</code></pre></p>"},{"location":"schema/jsonschema/#items","title":"<code>items</code>","text":"<p>Defines the schema for the elements in an array. The <code>items</code> keyword is used to describe what each item in the array should look like.</p> <p>Example: <pre><code>{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"string\"\n  }\n}\n</code></pre></p>"},{"location":"schema/jsonschema/#enum","title":"<code>enum</code>","text":"<p>Specifies a list of valid values that a property can take. This is useful for limiting the allowed options.</p> <p>Example: <pre><code>{\n  \"type\": \"string\",\n  \"enum\": [\"red\", \"green\", \"blue\"]\n}\n</code></pre></p>"},{"location":"schema/jsonschema/#additionalproperties","title":"<code>additionalProperties</code>","text":"<p>Determines whether properties not specified in the schema are allowed in the object. Setting this to <code>false</code> restricts the object to only the properties defined in <code>properties</code>.</p> <p>Example: <pre><code>{\n  \"additionalProperties\": false\n}\n</code></pre></p>"},{"location":"schema/jsonschema/#common-data-types-in-json-schema","title":"Common Data Types in JSON Schema","text":"<ul> <li>String: Used for text values.</li> <li>Number: Used for numeric values (both integers and floats).</li> <li>Boolean: Used for true/false values.</li> <li>Object: Used for JSON objects (dictionaries or key-value pairs).</li> <li>Array: Used for lists of items.</li> <li>Null: Used for null or empty values.</li> </ul>"},{"location":"schema/jsonschema/#example-of-a-complete-json-schema","title":"Example of a Complete JSON Schema","text":"<p>Here is an example of a complete JSON Schema for a simple user profile:</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2019-09/schema\",\n  \"$id\": \"http://example.com/user.json\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"number\"\n    },\n    \"name\": {\n      \"type\": \"string\"\n    },\n    \"email\": {\n      \"type\": \"string\",\n      \"format\": \"email\"\n    },\n    \"age\": {\n      \"type\": \"number\",\n      \"minimum\": 18\n    },\n    \"isActive\": {\n      \"type\": \"boolean\"\n    }\n  },\n  \"required\": [\"id\", \"name\", \"email\"]\n}\n</code></pre> <p>In this schema: - The <code>id</code> is a number, and the <code>name</code> and <code>email</code> are strings. - The <code>age</code> must be a number and must be at least 18. - The <code>isActive</code> property is a boolean. - The <code>id</code>, <code>name</code>, and <code>email</code> fields are required.</p>"},{"location":"schema/jsonschema/#conclusion","title":"Conclusion","text":"<p>JSON Schema is an essential tool for ensuring the integrity and validity of your data. It allows developers to define clear data models, validate data consistency, and improve communication between systems by setting expectations for the data structure.</p> <p>JSON Schema is widely supported across many platforms and libraries, making it a great choice for anyone working with APIs, databases, or web forms.</p>"},{"location":"schema/rendering/","title":"Rendering Methods","text":"<p>In DataEntry, users can customize the way each data entry is rendered by providing a <code>render</code> object inside the schema for each property. This allows control over how specific fields are displayed in the UI. Below we\u2019ll explain how you can provide a render object, customize it, and the detailed information about various rendering methods available, including the more complex <code>array-details</code> and <code>autosuggest</code> methods.</p>"},{"location":"schema/rendering/#providing-a-render-object","title":"Providing a Render Object","text":"<p>The <code>render</code> object is specified for each property inside the schema. It allows you to define how the UI should render specific data fields. This includes the method of rendering (such as <code>input</code>, <code>select</code>, <code>array-details</code>, etc.) and any additional attributes required for that rendering.</p>"},{"location":"schema/rendering/#example-of-a-render-object","title":"Example of a Render Object:","text":"<pre><code>{\n  \"type\": \"string\",\n  \"title\": \"Name\",\n  \"render\": {\n    \"method\": \"input\",\n    \"attributes\": [\n      { \"name\": \"name\" },\n      { \"placeholder\": \"Enter name\" }\n    ]\n  }\n}\n</code></pre> <p>In this example, the <code>render</code> object tells DataEntry to render the <code>name</code> field as an <code>input</code> element with a placeholder.</p>"},{"location":"schema/rendering/#customizing-render-objects","title":"Customizing Render Objects","text":"<p>Users can customize various aspects of the render object by adding: - method: The method defines the type of input or display element (e.g., <code>input</code>, <code>select</code>, <code>richtext</code>, etc.). - attributes: This array defines additional HTML attributes for the rendered element (e.g., <code>placeholder</code>, <code>type</code>, <code>disabled</code>, etc.).</p> <p>Additionally, the <code>render</code> object can include settings for advanced controls like <code>autosuggest</code> and <code>array-details</code>, allowing more complex behaviors and structures.</p>"},{"location":"schema/rendering/#render-methods","title":"Render Methods","text":""},{"location":"schema/rendering/#1-input","title":"1. Input","text":"<p>Renders a basic input field (e.g., text, number, date, etc.).</p> <pre><code>{\n  \"render\": {\n    \"method\": \"input\",\n    \"attributes\": [\n      { \"type\": \"text\" },\n      { \"placeholder\": \"Enter text here\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>Attributes: Specify standard HTML attributes like <code>type</code>, <code>placeholder</code>, <code>disabled</code>, etc.</li> </ul>"},{"location":"schema/rendering/#2-select","title":"2. Select","text":"<p>Renders a dropdown <code>&lt;select&gt;</code> element populated with options.</p> <pre><code>{\n  \"render\": {\n    \"method\": \"select\",\n    \"options\": \"condition\",\n    \"attributes\": [\n      { \"name\": \"condition\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>Options: The <code>options</code> field defines where the options will be pulled from (e.g., from a data source).</li> </ul> <p>TODO!</p>"},{"location":"schema/rendering/#3-richtext","title":"3. Richtext","text":"<p>Renders a rich text editor with various formatting options.</p> <pre><code>{\n  \"render\": {\n    \"method\": \"richtext\",\n    \"attributes\": [\n      { \"toolbar\": \"h1,h2,b,i,u,link\" }\n    ]\n  }\n}\n</code></pre>"},{"location":"schema/rendering/#4-array-details","title":"4. Array-Details","text":"<p>The <code>array-details</code> method is used to render arrays of data where each item can be expanded or collapsed using a <code>&lt;details&gt;</code> element. This method requires additional <code>label</code> and <code>value</code> properties to define the summary and display for each entry.</p>"},{"location":"schema/rendering/#example","title":"Example:","text":"<pre><code>{\n  \"type\": \"array\",\n  \"title\": \"Categories\",\n  \"render\": {\n    \"method\": \"array-details\",\n    \"label\": \"${name}\",\n    \"value\": \"${description}\",\n    \"add\": true,\n    \"delete\": true\n  },\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"name\": { \"type\": \"string\", \"title\": \"Category Name\" },\n      \"description\": { \"type\": \"string\", \"title\": \"Description\" }\n    }\n  }\n}\n</code></pre>"},{"location":"schema/rendering/#breakdown","title":"Breakdown:","text":"<ul> <li>label: This defines the text displayed in the <code>&lt;summary&gt;</code> element, which is used as the clickable area of the <code>&lt;details&gt;</code> toggle.</li> <li>value: The <code>value</code> defines the content displayed inside the expanded <code>&lt;details&gt;</code> section.</li> <li>add: A boolean that indicates if the user can add new entries to the array.</li> <li>delete: A boolean that indicates if the user can delete entries from the array.</li> </ul> <p>The <code>array-details</code> method is particularly useful for managing complex arrays of data where each item may have multiple fields, and users need to toggle the visibility of those fields for better organization.</p>"},{"location":"schema/rendering/#5-autosuggest","title":"5. Autosuggest","text":"<p>The <code>autosuggest</code> control is a more complex render method that allows users to enter text and receive suggestions based on data from an external API. This method is useful for fields like address lookup or selecting from a large dataset.</p>"},{"location":"schema/rendering/#example_1","title":"Example:","text":"<pre><code>{\n  \"type\": \"object\",\n  \"title\": \"Vendor\",\n  \"render\": {\n    \"method\": \"autosuggest\",\n    \"autosuggest\": {\n      \"api\": \"https://example.com/api/vendors?q=\",\n      \"apiArrayPath\": \"results\",\n      \"apiValuePath\": \"vendor.id\",\n      \"apiDisplayPath\": \"vendor.name\",\n      \"label\": \"Vendor Name\",\n      \"mapping\": {\n        \"vendor_id\": \"vendor.id\",\n        \"vendor_name\": \"vendor.name\"\n      },\n      \"syncInstance\": true\n    }\n  }\n}\n</code></pre>"},{"location":"schema/rendering/#breakdown_1","title":"Breakdown:","text":"<ul> <li>api: The URL of the API that returns suggestions.</li> <li>apiArrayPath: The path to the array in the API response that contains the suggestion data.</li> <li>apiValuePath: The path to the specific value to be stored (e.g., the ID of the vendor).</li> <li>apiDisplayPath: The path to the display value to be shown in the dropdown (e.g., the vendor name).</li> <li>mapping: Defines how values from the API response map to the fields in the form (e.g., vendor ID and name).</li> <li>syncInstance: A boolean that indicates whether the form instance should be synchronized with the selected value from the suggestions.</li> </ul>"},{"location":"schema/rendering/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>You can customize how data fields are rendered using the <code>render</code> object within the schema.</li> <li>Render methods like <code>array-details</code> and <code>autosuggest</code> allow for more advanced UI elements that can handle arrays of data and external data sources.</li> <li>Each render method supports additional attributes and settings to further tailor the behavior and appearance of the rendered elements.</li> </ul>"},{"location":"schema/validation/","title":"Schema Validation","text":"<p>DataEntry provides built-in validation for the schema-based form generation, ensuring that the data conforms to the specified schema. This can be customized using a user-provided validation method or the default validation mechanism.</p>"},{"location":"schema/validation/#how-validation-works","title":"How Validation Works","text":"<p>By default, DataEntry validates the form data based on the provided schema. It checks for:</p> <ul> <li>Required properties: Ensures that required properties are present in the data.</li> <li>Type matching: Validates that the values conform to the types specified in the schema (e.g., <code>string</code>, <code>number</code>, <code>array</code>, <code>object</code>, etc.).</li> </ul>"},{"location":"schema/validation/#disabling-validation-with-novalidate","title":"Disabling Validation with <code>novalidate</code>","text":"<p>If you want to disable validation entirely, you can add the <code>novalidate</code> attribute to the <code>&lt;data-entry&gt;</code> component:</p> <pre><code>&lt;data-entry\n  data=\"your.api/data\"\n  schema=\"your.api/schema\"\n  novalidate&gt;\n&lt;/data-entry&gt;\n</code></pre> <p>This disables both built-in and custom validation for the component.</p>"},{"location":"schema/validation/#custom-validation","title":"Custom Validation","text":"<p>DataEntry allows you to set your own custom validation method (such as ajv) using the <code>validateMethod</code> setter. The custom method should accept the schema and data as parameters and return an object containing a <code>valid</code> boolean and an <code>errors</code> array.</p>"},{"location":"schema/validation/#setting-a-custom-validation-method","title":"Setting a Custom Validation Method","text":"<p>You can set a custom validation method in JavaScript as shown below:</p> <pre><code>const myCustomValidator = (schema, data) =&gt; {\n  // Custom validation logic\n  return {\n    valid: true, // or false if validation fails\n    errors: []   // list of validation errors\n  };\n};\n\ndataEntryInstance.validateMethod = myCustomValidator;\n</code></pre> <p>The custom method is invoked instead of the default validation. If no custom method is set, the default validation is used.</p>"},{"location":"schema/validation/#using-validatemethod-in-javascript","title":"Using <code>validateMethod</code> in JavaScript","text":"<p>The <code>validateMethod</code> can be set directly in JavaScript if preferred over using the attributes:</p> <pre><code>const dataEntry = document.querySelector('data-entry');\ndataEntry.validateMethod = myCustomValidator;\n</code></pre>"},{"location":"schema/validation/#default-validation","title":"Default Validation","text":"<p>If no custom validation method is provided, the default validation function is used. The default validation checks if the data matches the expected structure and types defined in the schema.</p>"},{"location":"schema/validation/#default-validation-logic","title":"Default Validation Logic","text":"<p>The default validation checks: - If required properties are missing. - If data types match the expected type (<code>integer</code>, <code>string</code>, <code>boolean</code>, <code>array</code>, <code>object</code>, etc.). - If nested objects or arrays are properly structured.</p> <p>Here\u2019s an overview of the default validation process:</p> <pre><code>/**\n * Validates the given data against the provided schema.\n * \n * @param {object} schema - The schema object describing the expected structure of the data.\n * @param {object} data - The data object to be validated.\n * @returns {object} - An object containing:\n *   - valid: boolean indicating if the data is valid.\n *   - errors: array of error messages for any validation failures.\n */\nfunction validateData(schema, data) {\n  function validateObject(schema, data, path = '') {\n    let errors = [];\n\n    for (const key of Object.keys(schema.properties)) {\n      const propertyPath = path ? \\`\\${path}.\\${key}\\` : key;\n\n      if (schema.required?.includes(key) &amp;&amp; data[key] === undefined) {\n        errors.push({\n          message: 'Missing required property',\n          property: propertyPath,\n          type: schema.properties[key].type,\n          value: undefined\n        });\n        continue;\n      }\n\n      const propertySchema = schema.properties[key];\n      const value = data[key];\n\n      if (!validateType(value, propertySchema.type)) {\n        errors.push({\n          message: 'Invalid type for property',\n          property: propertyPath,\n          type: propertySchema.type,\n          value\n        });\n        continue;\n      }\n\n      if (propertySchema.type === 'object') {\n        const result = validateObject(propertySchema, value, propertyPath);\n        errors = errors.concat(result.errors);\n      } else if (propertySchema.type === 'array') {\n        if (!Array.isArray(value)) {\n          errors.push({\n            message: 'Invalid type for array property',\n            property: propertyPath,\n            type: 'array',\n            value\n          });\n        } else {\n          value.forEach((item, index) =&gt; {\n            const result = validateObject(propertySchema.items, item, \\`\\${propertyPath}[\\${index}]\\`);\n            errors = errors.concat(result.errors);\n          });\n        }\n      }\n    }\n\n    return { valid: errors.length === 0, errors };\n  }\n\n  return validateObject(schema, data);\n}\n</code></pre>"},{"location":"schema/validation/#validating-data-types","title":"Validating Data Types","text":"<p>The following types are supported in the default validation:</p> <ul> <li>integer</li> <li>string</li> <li>boolean</li> <li>number</li> <li>array</li> <li>object</li> <li>null</li> </ul> <p>If the data does not match the expected type, an error is returned.</p> <pre><code>function validateType(value, type) {\n  if (Array.isArray(type)) {\n    return type.some(t =&gt; validateType(value, t));\n  }\n  if (type === \"integer\") return Number.isInteger(value);\n  if (type === \"string\") return typeof value === \"string\";\n  if (type === \"boolean\") return typeof value === \"boolean\";\n  if (type === \"number\") return typeof value === \"number\" &amp;&amp; !isNaN(value);\n  if (type === \"array\") return Array.isArray(value);\n  if (type === \"object\") return typeof value === \"object\" &amp;&amp; !Array.isArray(value) &amp;&amp; value !== null;\n  if (type === \"null\") return value === null;\n  return false;\n}\n</code></pre>"},{"location":"schema/validation/#conclusion","title":"Conclusion","text":"<p>The <code>validateMethod</code> allows users to provide custom validation logic to extend or replace the built-in validation. The built-in validation ensures data consistency based on the schema. The <code>novalidate</code> attribute can be used to skip validation when necessary. </p> <p>With these options, DataEntry provides a flexible validation system to ensure your data is valid before submission.</p>"}]}