
# Dynamic Functions in DataEntry

Dynamic functions in **DataEntry** provide a flexible way to inject dynamic values into the schema or the form. These functions can be used to generate values that are evaluated at runtime, such as timestamps, unique identifiers, or other user-defined logic. This document explains the built-in dynamic functions, how to extend them with custom functions, and how to use them in the schema.

## Built-in Dynamic Functions

### 1. **now**

The `now` function returns the current date and time in the format `yyyy-MM-ddThh:mm`. This can be used for setting default date-time values in the schema.

#### Example Output:
```
2024-09-23T14:30
```

### 2. **uuid**

The `uuid` function generates a universally unique identifier (UUID). This is useful when you need to create unique keys for new data entries.

#### Example Output:
```
b1b754a0-5c12-11ec-bf63-0242ac130002
```

### 3. **today**

The `today` function returns the current date in `yyyy-MM-dd` format, which is commonly used for date input fields.

#### Example Output:
```
2024-09-23
```

## Using Dynamic Functions in the Schema

You can use dynamic functions directly within the schema to set default values for form fields. The values generated by these functions are injected into the form at runtime.

### Syntax for Using Dynamic Functions

Dynamic functions in the schema should be referenced using the following pattern:

```
"value": "${d:functionName}"
```

Here, `${d:functionName}` represents a dynamic function, where `d` stands for "dynamic" and `functionName` is the name of the function you want to call.

### Example:

```json
{
  "type": "object",
  "properties": {
    "created_at": {
      "type": "string",
      "title": "Created At",
      "value": "${d:now}",
      "render": {
        "method": "input",
        "attributes": [
          { "name": "created_at" }
        ]
      }
    },
    "unique_id": {
      "type": "string",
      "title": "Unique ID",
      "value": "${d:uuid}",
      "render": {
        "method": "input",
        "attributes": [
          { "name": "unique_id" }
        ]
      }
    }
  }
}
```

In this example:
- The **created_at** field will have the current date and time as the default value.
- The **unique_id** field will have a generated UUID as the default value.

## Extending Dynamic Functions

You can define your own dynamic functions to extend the functionality provided by DataEntry. To do this, use the `extendDynamicFunction` method, which allows you to add custom functions to the `dynamicFunctions` object.

### Syntax for Extending Dynamic Functions

```javascript
export function extendDynamicFunction(name, func) {
  if (typeof func === 'function') {
    dynamicFunctions[name] = func;
  } else {
    console.error(`Failed to extend: ${name} is not a function`);
  }
}
```

### Example:

```javascript
// Define a custom dynamic function that returns the current year
extendDynamicFunction('currentYear', () => {
  return new Date().getFullYear();
});

// Now you can use ${d:currentYear} in your schema
```

### Usage in Schema:

```json
{
  "type": "object",
  "properties": {
    "year": {
      "type": "number",
      "title": "Year",
      "value": "${d:currentYear}",
      "render": {
        "method": "input",
        "attributes": [
          { "name": "year" }
        ]
      }
    }
  }
}
```

In this example:
- The **year** field will automatically be populated with the current year using the custom `currentYear` dynamic function.

## Conclusion

Dynamic functions allow you to inject real-time values into your forms in **DataEntry**. With built-in support for functions like `now`, `uuid`, and `today`, you can handle many common cases easily. By extending dynamic functions using the `extendDynamicFunction` method, you can customize the behavior to suit your application's specific needs.
